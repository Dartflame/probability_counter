# probability_counter

Данный алгоритм предназначен для решения задачи, условия которой лежат в изображениях condition1 and condition2 в корне проекта.

Логика алгоритма:

ШАГ-1 : парсим входящую строгу регуляркой и складываем в список все операнды (числа и броски кубика)

ШАГ-2: с помощью метода parse превращаем список операндов в список карт вероятностей (дальше - КВ). Карта вероятности - это мапа, где ключи - возможные исходы, 
а значения - результат их наступления. Для обычного числа это КВ из 1 элемента - число(ключ) и 1.0 (100% вероятность). Для кубиков dN это КВ из N элементов, где ключи
это все значения от 1 до N включительно, а значения - вероятности - 1.0/N (для кубика d4 КВ это (1-0.25, 2-0.25, 3-0.25, 4-0.25)).

ШАГ-3: методом createExpression из входящей строки создаем строку, в которой все операнды заменены на номера соответствующих элементов списка КВ. То есть, например, 
стартовое выражение d4+d3 мы заменяем на 0+1 (d4 это нулевой элемент, d3 - первый). Зачем - поймете позже :)

ШАГ-4: если в выражении есть скобки вызываем метод openBraces где собственнно и происходит большая часть магии. В нем мы регуляркой разбираем наше выражение,
находим самые глубокие вложенные скобки и начинаем собственно вычисления.

ШАГ-4.1: из полученного выражения (например д3+2-д4) мы делаем список операторов (+,-). И начинаем вычислять в порядке приоритета - сначала умножение, потом +-, потом >,
после чего обновляем наше выражение пока не закончатся скобки. Когда операторов в скобках больше нет - мы убираем скобки вычисляем последнее выражение.

ШАГ-5: Вычисления. для этого есть три метода multiplyAction, plusMinusAction и boolAction, они делают все примерно одно и то же, в целом их можно было объединить и в один,
но так проще вылавливать ошибки. Логика тут такая: в методы мы передаем список операторов и выражение (например д3+д4+д5, но не забываем, что оно у нас оно в формате 1+2+3,
где числа это номера элементов в списке КВ). 

Мы итерируемся по этой строке и когда находим символ "+" - с помощью регулярки достаем операнды слева и справа и 
получаем строку формата 1+2. Это значит что элемент 1 и 2 списка КВ надо сложить между собой. для этого есть метод action который принимает две КВ - левый и правый операнд 
и символ математического знака. В зависимости от знака проводим операцию. 

Как сложить две карты вероятностей? Мы делаем цикл+вложенный цикл и каждого значения из первой карты
складываем с каждым значением и второй, а итоговая вероятность сумма - это перемноженные вероятности. Если результат уже есть в КВ суммы - то мы складываем для него вероятности.
То есть 3+1 = 4 и 2+2 = 4. Если у каждого из событий вероятность 10%, то суммарная вероятность получить 4 будет 20%.

Дальше мы делаем вот такое колдовство - результат вычисления выражения 1+2 (это новая КВ) мы кладем в конец списка КВ, а само выражение 1+2 в строке 1+2+3 мы заменяем 
на номер последнего элемента списка (который только что добавили), итого получается 4+3. То есть мы сложили первый и второй элемент списка КВ. Получили элемент №4 и подставили 
его на позицию 1+2, после чего (не забываем что у нас цикл) значение указателя сдвигаем на 1 назад. И дальше мы находим следующий оператор +, находим выражение 4+3, вычисляем
и заменяем на 5. Итого вместо 1+2+3 у нас получается 5. Это пятый элемент списка КВ. 

ШАГ-5.1: иначе вычисляется логический оператор >, у него всего два ключа 0 и 1. И в зависимости от характера операндов мы применияем в методе parseBoolean разную логику. 
Всего у нас 2 возможных случая - два числа, слева кубик и справа число, справа кубок и слева число, два кубика (понять это легко - для двух чисел размеры КВ будт равны единице,
для двух кубиков размеры КВ будут строго больше единицы и тд). В принципе дальше там все понятно в коде метода.

Ну и все, когда у нас заканчиваются операторы - значит все вычисления сделаны. И итоговый результат хранится в последнем элементе списка КВ.



